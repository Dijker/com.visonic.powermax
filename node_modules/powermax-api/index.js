"use strict";

var PowerMax = require('./lib/core.js'),
	pm = require('./lib/tables.js');

var debugOn = true;
var panels = [];
var sensorQueue = [];
var panelState = [];
var locale = Homey.manager('i18n').getLanguage();

var allowArming = 'all';
	
// Debug logging
function debug(text) {
	if (debugOn) {
		var now = new Date();
		if (typeof text == 'object') {
			var output = '';
			for (var property in text) {
			  output += property + ': ' + text[property]+'; ';
			};
			text = output;
		}
		var time = now.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1");
		var ms = ('00' + now.getMilliseconds()).slice(-3);
		Homey.log(time + '.' + ms + ' ' + text);
	}
}

var self = module.exports = {
	// debug function
	debug: debug,
	
	// Add a new panel or search for one
	addPanel: function(driver, device, settings) {
		// use ip:port as temporary id if serial not known yet
		var id = device == null ? settings.ip + ':' + settings.port : device.id;
		if (panels[id] == null) {
			var powermax = new PowerMax(settings, debug);
			// Add event handlers
			powermax.events.on('found', function(data) {
				if (!data.found) {
					delete panels[id];
				}
				Homey.emit('found', data);
			});
			powermax.events.on('download', function(state) {
				var data = { 
					state: state,
					id: id,
					show: {}
				};
				if (state == 'process:MSG_DL_SERIAL') {
					// Switch from ip:port id to serial number id
					delete panels[id];
					id = powermax.settings.config.panelSerial;
					panels[id] = powermax;
					data.id = id;
					if (device != null) {
						self.addPanelActions(driver, device);
					}
				}
				// If download completed, add panel
				if (state == 'done') {
					data.device = {
						name: powermax.settings.config.panelType,
						data: {	id: id },
						settings: settings
					}
				}
				// Build up the information we show in the front-end
				for (var i in pm.info) {
					var item = pm.info[i];
					var val = powermax.settings.config[item.val];
					if (val != null) {
						data.show[i] = { name: item[locale], val: val };
					}
				}
				// Let front-end know of updated info
				Homey.emit('download', data);
			});
		} else {
			debug('Error: panel ' + id + ' already present.');
			Homey.emit('found', { found: false });
		}
	},
	
	// Add panel actions & child device actions
	addPanelActions: function(driver, device) {
		var id = device.id;
		panels[id].events.on('system', function(id, field, newVal) {
			if (field == 'status') {
				var state = 'disarmed';
				if (newVal.nr == 4) { // Armed Home
					state = 'partially_armed';
				} else if (newVal.armed) {
					state = 'armed';
				}
				panelState[device.id] = state;
				driver.realtime(device, 'homealarm_state', state, function(err, success) {
					debug('Real-time panel update: ' + (err ? err : 'OK'));
				});
			}
		});
		// Add sensors in the queue (if any)
		if (sensorQueue[id] != null) {
			for (var i = 0; i < sensorQueue[id].length; i++) {
				var sensor = sensorQueue[id].shift();
				self.addDevice(sensor.driver, sensor.device);
			}
		}
	},
	
	// Remove a panel
	deletePanel: function(id) {
		if (panels[id] != null) {
			panels[id].closeConnection();
			delete panels[id];
		} else {
			debug('Error: panel ' + id + ' not present.');
		}
	},
	
	// Get a list of all registered panels
	getPanels: function() {
		var list = [];
		for (var item in panels) {
			var elem = panels[item].settings.config;
			list.push({ 
				id: item,
				type: elem.panelType,
				name: elem.panelName,
				serial: elem.panelSerial
			});
		}
		return list;
	},
	
	// Update panel configuration settings
	updateSettings: function(panel, changedItems, newSettings) {
		for (var i in changedItems) {
			var item = changedItems[i];
			var newVal = newSettings[item];
			Homey.log(item + ':' + newVal);
			// update setting
			panels[panel].devSettings[item] = newVal;
			// check if special action needed
			if (item == 'ip' || item == 'port') {
				// TODO: close connection & restart
			} else if (item == 'syncTime' && newVal) {
				panels[panel].syncTime();
			}
		}
	},
	
	// Add a sensor device
	addDevice: function(driver, device) {
		debug("Adding device " + device.id);
		var panel = device.panel;
		if (panels[panel] != null) {
			var did = device.id.split(':');
			panels[panel].events.on('zone', function(id, field, newVal) {
				if (id == did[1]) {
					if (field == 'battery') {
						driver.realtime(device, 'alarm_battery', newVal, function(err, success) {
							debug('Real-time battery update: ' + (err ? err : 'OK'));
						});
					} else if (field == 'tamper') {
						driver.realtime(device, 'alarm_tamper', newVal, function(err, success) {
							debug('Real-time tamper update: ' + (err ? err : 'OK'));
						});
					} else if (field == 'trip') {
						var event = (did[0] == 'magnet') ? 'alarm_contact' : (did[0] == 'motion' ? 'alarm_motion' : 'alarm_smoke');
						driver.realtime(device, event, newVal, function(err, success) {
							debug('Real-time tripped update: ' + (err ? err : 'OK'));
						});
					}
				}
			});
		} else {
			// Panel not added yet...
			if (sensorQueue[panel] == null) {
				sensorQueue[panel] = [];
			}
			sensorQueue[panel].push({ driver: driver, device: device });
		}
	},
	
	// Delete a (sensor) device
	deleteDevice: function(device) {
		debug("Deleting device " + device.id);
		// TODO: remove events
	},
	
	// Get sensors
	getSensors: function(panel, type) {
		var items = [];
		if (panels[panel] != null) {
			var list = panels[panel].settings.zones;
			if (panels[panel].readAllSettings) {
				for (var idx in list) {
					var elem = list[idx];
					if ((type == 'magnet' || type == 'wired') && elem.stype == 'Magnet') {
						var capabilities = ['alarm_contact', 'alarm_tamper'];
						if (type == 'magnet') {
							capabilities.splice(1, 0, 'alarm_battery');
						}
						items.push({
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'magnet:' + idx, panel: panel, zone: idx },
							capabilities: capabilities
						});
					} else if (type == 'motion' && elem.stype == 'Motion') {
						items.push({ 
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'motion:' + idx, panel: panel, zone: idx },
							capabilities: ['alarm_motion', 'alarm_battery', 'alarm_tamper']
						});
					} else if (type == 'smoke' && elem.stype == 'Smoke') {
						items.push({ 
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'smoke:' + idx, panel: panel, zone: idx },
							capabilities: ['alarm_smoke', 'alarm_battery', 'alarm_tamper']
						});
					}
				}
			}
		}
		return items;
	},
	
	// Get a sensor value
	getValue: function(trigger, panel, zone, callback) {
		if (panels[panel] != null) {
			if (trigger == 'alarm_contact' || trigger == 'alarm_motion' || trigger == 'alarm_smoke') {
				var val = panels[panel].panel.zone[zone].trip;
				debug('Tripped: ' + val);
			} else if (trigger == 'alarm_battery') {
				var val = panels[panel].panel.zone[zone].battery;
				debug('Battery: ' + val);
			} else if (trigger == 'alarm_tamper') {
				var val = panels[panel].panel.zone[zone].tamper;
				debug('Tamper: ' + val);
			}
			callback(null, val);
		} else {
			// Panel has been removed
			callback('Panel does not exist');
		}
	},
	
	// Get the state of the panel
	getPanelState: function(panel) {
		return panelState[panel];
	},

	// Set the state of the panel
	setPanelState: function(panel, state, callback) {
		var newState = (state == 'partially_armed' ? 'Stay' : state[0].toUpperCase() + state.slice(1));
		var armCode = pm.armMode[newState];
		var allowed = true;
		var allowArming = panels[panel].devSettings.allowArm;

		debug('setPanelState ' + (state || 'N/A'));
		if (armCode != null) {
			if (allowArming == 'none') {
				allowed = false;
			} else if (allowArming == 'arm') {
				allowed = (armCode & 0x5) == 0x5;
			} else if (allowArming == 'stay') {
				allowed = (armCode & 0x5) != 0;
			} else {
				allowed = true;
			}
			if (allowed) {
				var pin = panels[panel].settings.config.userCode[0];
				panels[panel].sendMessage("MSG_ARM", { arm: [ armCode ], pin: pin });
				callback(null, true);
			} else {
				callback('Not allowed', false);
			}
		} else {
			callback('Invalid state requested', false);
		}
	}
}
