"use strict";

var PowerMax = require('./lib/core.js'),
	pm = require('./lib/tables.js');

var debugOn = true;
var panels = {};
var sensors = {};
var sensorQueue = {};
var panelState = {};
var locale = Homey.manager('i18n').getLanguage();


// Debug logging
function debug(text) {
	if (debugOn) {
		var now = new Date();
		if (typeof text == 'object') {
			var output = '';
			for (var property in text) {
			  output += property + ': ' + text[property]+'; ';
			};
			text = output;
		}
		var time = now.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1");
		var ms = ('00' + now.getMilliseconds()).slice(-3);
		Homey.log(time + '.' + ms + ' ' + text);
	}
}

var self = module.exports = {
	// debug function
	debug: debug,
	
	// getPanel
	getPanel: function(id) {
		return panels[id];
	},
	
	// Add a new panel or search for one
	addPanel: function(driver, device, settings) {
		// use ip:port as temporary id if serial number not known yet
		var id = device == null ? settings.ip + ':' + settings.port : device.id;
		if (panels[id] == null) {
			for (var p in panels) {
				var pip = panels[p].devSettings.ip + ':' + panels[p].devSettings.port;
				if (id == pip) {
					debug('Error: panel ' + id + ' already present.');
					Homey.emit('found', { found: false });
					return null;
				}
			}
			var powermax = new PowerMax(settings, debug);
			if (device != null) { // ID is correct
				panels[id] = powermax;
				sensors[id] = [];
				self.addPanelActions(driver, device);
			}
			// Add event handlers
			powermax.events.on('found', function(data) {
				if (!data.found) {
					// Remove the panel entry if the ID is ip:port, which means we 
					// never found a serial number. If we have found a serial number
					// we keep the panel in the list (needs explicit deletePanel).
					if (id.indexOf(':') > 0) {
						delete panels[id];
					} else {
						debug('Marking panel ' + id + ' as unavailable');
						// Mark the panel and sensors as unavailable
						driver.setUnavailable(device, __('unreachable'));
						if (sensors[id] != null) {
							for (var i = 0; i < sensors[id].length; i++) {
								sensors[id][i].driver.setUnavailable(sensors[id][i].device, __('no_panel'));
							}
						}
					}
				} else {
					debug('Marking panel ' + id + ' as available');
					// Panel has been found, mark all as active
					driver.setAvailable(device);
					if (sensors[id] != null) {
						for (var i = 0; i < sensors[id].length; i++) {
							sensors[id][i].driver.setAvailable(sensors[id][i].device);
						}
					}
				}
				Homey.emit('found', data);
			});
			powermax.events.on('download', function(state) {
				var data = { 
					state: state,
					id: id,
					show: {}
				};
				if (state == 'process:MSG_DL_SERIAL') {
					// Switch from ip:port id to serial number id
					var newId = powermax.settings.config.panelSerial || id;
					if (id != newId && sensors[newId] == null) {
						id = newId;
						sensors[id] = [];
					}
					data.id = id;
					panels[id] = powermax;
				}
				// Build up the information we show in the front-end
				for (var i in pm.info) {
					var item = pm.info[i];
					var val = powermax.settings.config[item.val];
					if (val != null) {
						data.show[i] = { name: item[locale], val: val };
					}
				}
				// If download completed, add panel
				if (state == 'done') {
					data.device = {
						name: powermax.settings.config.panelType,
						data: {	id: id },
						settings: settings
					}
					// Add zone information to show
					for (var z in powermax.settings.zones) {
						var zone = powermax.settings.zones[z];
						data.show['zone' + z] = { 
							name: zone.zname + ' (zone ' + z + ')', 
							val: zone.stype + ' sensor (' + zone.ztypeName + ')' }
					}
				}
				// Let front-end know of updated info
				Homey.emit('download', data);
			});
		} else {
			debug('Error: panel ' + id + ' already present.');
			Homey.emit('found', { found: false, err: 'Already present' });
		}
		return id;
	},
	
	// Add panel actions & child device actions
	addPanelActions: function(driver, device) {
		var id = device.id;
		if (panels[id] != null) {
			panels[id].events.on('system', function(field, newVal) {
				if (field == 'status') {
					var state = 'disarmed';
					if (newVal.nr == 4) { // Armed Home
						state = 'partially_armed';
					} else if (newVal.armed) {
						state = 'armed';
					}
					panelState[device.id] = state;
					driver.realtime(device, 'homealarm_state', state, function(err, success) {
						debug('Real-time panel update: ' + (err ? err : 'OK'));
					});
				}
			});
		}
		// Add sensors in the queue (if any)
		if (sensorQueue[id] != null) {
			for (var i = 0; i < sensorQueue[id].length; i++) {
				var sensor = sensorQueue[id][i];
				self.addSensor(sensor.driver, sensor.device);
				sensor.driver.setAvailable(sensor.device);
			}
		}
	},
	
	// Remove a panel
	deletePanel: function(id) {
		if (panels[id] != null) {
			panels[id].found = false; // make sure we don't re-open the connection
			panels[id].closeConnection();
			// mark all sensors as unavailable
			if (sensors[id] != null) { // fix #7
				for (var i = 0; i < sensors[id].length; i++) {
					sensors[id][i].driver.setUnavailable(sensors[id][i].device, __('no_panel'));
				}
			}
			delete panels[id];
			delete sensors[id];
		} else {
			debug('Error: panel ' + id + ' not present.');
		}
	},
	
	// Get a list of all registered panels
	getPanels: function() {
		var list = [];
		for (var item in panels) {
			var elem = panels[item].settings.config;
			list.push({ 
				id: item,
				type: elem.panelType,
				name: elem.panelName,
				serial: elem.panelSerial
			});
		}
		return list;
	},
	
	// Update panel configuration settings
	updateSettings: function(panel, changedItems, newSettings) {
		if (panels[panel] != null) { // Fix #5
			var p = panels[panel];
			var restart = false;
			for (var i in changedItems) {
				var item = changedItems[i];
				var newVal = newSettings[item];
				// update setting
				p.devSettings[item] = newVal;
				// check if special action needed
				if (item == 'ip' || item == 'port') {
					// We will need to close connection & restart
					restart = true;
				} else if (item == 'syncTime' && newVal) {
					p.syncTime();
				}
			}
			if (restart) {
				p.closeConnection();
				p.found = false;
				p.openConnection(p.devSettings.ip, p.devSettings.port);
			}
		} else {
			debug('Panel ' + panel + ' does not exist!');
		}
	},
	
	// Add a sensor device
	addSensor: function(driver, device) {
		var panel = device.panel;
		if (panels[panel] != null) {
			debug("Adding device " + device.id);
			sensors[panel].push({ driver: driver, device: device });
			var did = device.id.split(':');
			panels[panel].events.on('zone.' + did[1], function(field, newVal) {
				if (field == 'battery') {
					driver.realtime(device, 'alarm_battery', newVal, function(err, success) {
						debug('Real-time battery update zone ' + did[1] + ': ' + (err ? err : 'OK'));
					});
				} else if (field == 'tamper') {
					driver.realtime(device, 'alarm_tamper', newVal, function(err, success) {
						debug('Real-time tamper update zone ' + did[1] + ': ' + (err ? err : 'OK'));
					});
				} else if (field == 'trip') {
					var event = (did[0] == 'magnet') ? 'alarm_contact' : (did[0] == 'motion' ? 'alarm_motion' : 'alarm_smoke');
					driver.realtime(device, event, newVal, function(err, success) {
						debug('Real-time tripped update zone ' + did[1] + ': ' + (err ? err : 'OK'));
					});
				}
			});
		} else {
			// Panel not added yet...
			if (sensorQueue[panel] == null) {
				sensorQueue[panel] = [];
			}
			// or no panel at all?
			driver.setUnavailable(device, __('no_panel'));
			sensorQueue[panel].push({ driver: driver, device: device });
		}
	},
	
	// Delete a sensor device
	deleteSensor: function(device) {
		debug("Deleting device " + device.id);
		var panel = device.panel;
		if (sensors[panel] != null) { // fix #4
			for (var i = 0; i < sensors[panel].length; i++) {
				if (sensors[panel][i].device.id == device.id) {
					sensors[panel].splice(i, 1);
				}
			}
		}
		// TODO: remove events
	},
	
	// Get sensors
	getSensors: function(panel, type) {
		var items = [];
		if (panels[panel] != null) {
			debug('Panel exists');
			var list = panels[panel].settings.zones;
			if (panels[panel].readAllSettings) {
				debug('readAllSettings');
				for (var idx in list) {
					var elem = list[idx];
					if ((type == 'magnet' || type == 'wired') && elem.stype == 'Magnet') {
						var capabilities = ['alarm_contact', 'alarm_tamper'];
						if (type == 'magnet') {
							capabilities.splice(1, 0, 'alarm_battery');
						}
						items.push({
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'magnet:' + idx, panel: panel, zone: idx },
							capabilities: capabilities
						});
					} else if (type == 'motion' && elem.stype == 'Motion') {
						items.push({ 
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'motion:' + idx, panel: panel, zone: idx },
							capabilities: ['alarm_motion', 'alarm_battery', 'alarm_tamper']
						});
					} else if (type == 'smoke' && elem.stype == 'Smoke') {
						items.push({ 
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'smoke:' + idx, panel: panel, zone: idx },
							capabilities: ['alarm_smoke', 'alarm_battery', 'alarm_tamper']
						});
					}
				}
			}
		}
		return items;
	},
	
	// Get a sensor value
	getZoneValue: function(trigger, panel, zone, callback) {
		if (panels[panel] != null) {
			var zone = 'zone.' + zone;
			var val;
			if (panels[panel].zone[zone] != null) { // fix #3
				if (trigger == 'alarm_contact' || trigger == 'alarm_motion' || trigger == 'alarm_smoke') {
					val = panels[panel].zone[zone].trip;
					debug('Tripped: ' + val);
				} else if (trigger == 'alarm_battery') {
					val = panels[panel].zone[zone].battery;
					debug('Battery: ' + val);
				} else if (trigger == 'alarm_tamper') {
					val = panels[panel].zone[zone].tamper;
					debug('Tamper: ' + val);
				}
			}
			callback(null, val);
		} else {
			// Panel has been removed
			callback('Panel does not exist');
		}
	},
	
	// Get the name of the zone
	getZoneName: function(panel, zone) {
		var name = locale == 'en' ? 'Unknown' : 'Onbekend';
		if (panels[panel] != null) {
			var zones = panels[panel].settings.zones;
			if (zones != null && zones[zone] != null) {
				name = zones[zone].zname;
			}
		}
		return name;
	},
	
	// Get the state of the panel
	getPanelState: function(panel) {
		return panelState[panel];
	},

	// Set the state of the panel
	setPanelState: function(panel, state, callback) {
		if (panels[panel] != null) {
			var newState = (state == 'partially_armed' ? 'Stay' : state[0].toUpperCase() + state.slice(1));
			var armCode = pm.armMode[newState];
			var allowed = true;
			var allowArming = panels[panel].devSettings.allowArm;

			debug('setPanelState ' + (state || 'N/A'));
			if (armCode != null) {
				if (allowArming == 'none') {
					allowed = false;
				} else if (allowArming == 'arm') {
					allowed = (armCode & 0x5) == 0x5;
				} else if (allowArming == 'stay') {
					allowed = (armCode & 0x5) != 0;
				}
				if (allowed) {
					var pin = panels[panel].settings.config.userCode[0];
					panels[panel].sendMessage("MSG_ARM", { arm: [ armCode ], pin: pin });
					callback(null, true);
				} else {
					callback('Not allowed');
				}
			} else {
				callback('Invalid state requested');
			}
		} else {
			callback('Panel does not exist');
		}
	},
	
	// Get the status of a panel variable
	getPanelValue: function(panel, name) {
		var result;
		if (panels[panel] != null && panels[panel].zone.system != null) {
			result = panels[panel].zone.system[name];
		}
		return result;
	},
	
	// Set the time on the PowerMax panel
	setClock: function(panel) {
		if (panels[panel] != null) {
			panels[panel].syncTime();
		}
	}
}
