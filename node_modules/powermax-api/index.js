"use strict";

const PowerMax = require('./lib/core.js'),
	  pm = require('./lib/tables.js');

const locale = Homey.manager('i18n').getLanguage();

var debugOn = false;
var panels = {};
var deviceQueue = [];
var panelSearch;


// Debug logging
function debug() {
	if (debugOn) {
		var now = new Date();
		var itemdebug = (x) => { return (typeof x === 'object' ? JSON.stringify(x) : x) + ' ' };
		var time = now.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1");
		var ms = ('00' + now.getMilliseconds()).slice(-3);
		var text = '';
		for (var i = 0; i < arguments.length; i++) {
			var x = arguments[i];
			if (Object.prototype.toString.call(arguments[i]) === '[object Arguments]') {
				for (var j = 0; j < x.length; j++) {
					text += itemdebug(x[j]);
				}
			} else {
				text += itemdebug(x);
			}
		}
		Homey.log(time + '.' + ms, text.slice(0, -1));
	}
}

// Add devices to the queue if the panel is not active yet
function addToQueue(panel, data) {
	// Panel not added yet...
	if (deviceQueue[panel] == null) {
		deviceQueue[panel] = [];
	}
	// or no panel at all?
	data.driver.setUnavailable(data.device, __('error.no_panel'));
	deviceQueue[panel].push(data);
}

var self = module.exports = {
	// debug function
	debug: debug,
	
	// turn debugging on/off
	setDebug: function(on_off) {
		debugOn = on_off;
	},
	
	// Add a new panel or search for one
	addPanel: function(driver, device, name, settings) {
		// During a search there is no device id yet
		var id = device == null ? null : device.id;
		var search = settings.ip + ':' + settings.port;
		var err = null;
		if (panels[id] != null) {
			err = __('error.already_present', { panel: id });
		} else {
			// Check all panels whether there is already one on this ip:port
			for (var p in panels) {
				var pip = panels[p].settings.ip + ':' + panels[p].settings.port;
				if (search == pip) {
					search += ' (' + p + ')';
					err = __('error.already_present', { panel: search });
				}
			}
		}
		if (err != null) {
			debug(err);
			Homey.emit('found', { found: false, err: err });
			return err;
		}
		var powermax = new PowerMax(id, settings, debug);
		if (device != null) { // ID is correct, not a search
			panels[id] = { 
				pm: powermax,
				name: name,
				settings: settings, // device settings
				state: {},
				children: []
			}
			// Register handlers
			self.addPanelActions(driver, device);
		} else {
			panelSearch = powermax;
		}
		// Add event handlers
		powermax.events.on('found', function(data) {
			if (id != null) {
				var available = (panels[id] == null ? false : panels[id].available);
				if (!data.found && available != false) {
					debug('Marking panel', id, 'as unavailable');
					// Mark the panel and devices as unavailable
					panels[id].available = false;
					driver.setUnavailable(device, __('error.unreachable', { 
						time: new Date().toLocaleString(locale)
					}));
					for (var i = 0; i < panels[id].children.length; i++) {
						var child = panels[id].children[i];
						child.driver.setUnavailable(child.device, __('error.no_panel'));
					}
				} else if (data.found && !available) {
					debug('Marking panel', id, 'as available');
					// Panel has been found, mark all as active
					panels[id].available = true;
					driver.setAvailable(device);
					for (var i = 0; i < panels[id].children.length; i++) {
						var child = panels[id].children[i];
						child.driver.setAvailable(child.device);
					}
				}
			}
			Homey.emit('found', data);
		});
		powermax.events.on('download', function(state) {
			// Only relevant when we are searching for a panel
			if (panelSearch != null) {
				var data = { 
					state: state,
					id: id,
					show: {}
				};
				if (state == 'process:MSG_DL_SERIAL') {
					// Now we have the device id (use outer var!)
					id = powermax.settings.config.panelSerial;
					data.id = id;
					panels[id] = {
						pm: powermax,
						name: name,
						settings: settings,
						state: {},
						children: []
					}
				}
				// Build up the information we show in the front-end
				for (var i in pm.info) {
					var item = pm.info[i];
					var val = powermax.settings.config[item.val];
					if (val != null) {
						data.show[i] = { name: item[locale], val: val };
					}
				}
				// If download completed, add panel
				if (state == 'done') {
					// Add read-only settings
					var cfg = powermax.settings.config;
					settings.type = cfg.panelType;
					settings.model = cfg.panelModel;
					settings.serial = cfg.panelSerial;
					settings.firmware = cfg.panelSoftware + ' (' + cfg.panelEprom + ')';
					data.device = {
						name: powermax.settings.config.panelType,
						data: {	id: id },
						settings: settings
					}
					// Update our local variable as well
					device = data.device.data;
					// Register handlers
					self.addPanelActions(driver, device);
					// Add zone information to show
					for (var z in powermax.settings.zones) {
						var zone = powermax.settings.zones[z];
						// TODO: add translation stype
						data.show['zone' + z] = { 
							name: zone.zname + ' (zone ' + z + ')', 
							val: zone.stype + ' sensor (' + zone.ztypeName + ')'
						}
					}
					// Add x10 information to show
					for (var x in powermax.settings.x10) {
						var x10 = powermax.settings.x10[x];
						if (x10.enabled) {
							data.show['x10:' + x] = { 
								name: x10.name, 
								val: x10.loc
							}
						}
					}
				}
				// Let front-end know of updated info
				Homey.emit('download', data);
			} else {
				// Regular download, not for adding panel
				if (state == 'done' && panels[id] != null && panels[id].children != null) {
					var list = panels[id].pm.settings.zones;
					for (var i = 0; i < panels[id].children.length; i++) {
						var sensor = panels[id].children[i];
						if (sensor.type == 'sensor') {
							var elem = list[sensor.device.zone];
							if (elem == null) {
								// Sensor has been removed from panel
								sensor.driver.setUnavailable(sensor.device, __('error.sensor_removed'));
							} else {
								sensor.driver.setAvailable(sensor.device);
								// Update sensor setting info
								var setting = {
									location: elem.zname,
									type: elem.ztypeName,
									chime: elem.zchime,
									partition: elem.partition.join(', ')
								};
								sensor.driver.setSettings(sensor.device, setting);
							}
						}
					}
				}
			}
		});
		return err;
	},
	
	// Add panel actions & child device actions
	addPanelActions: function(driver, device) {
		var id = device.id;
		if (panels[id] != null) {
			debug('Adding panel events for', id);
			// Catch system events
			panels[id].pm.events.on('system', function(field, newVal) {
				debug('Received system event for field', field, 'with value', newVal);
				if (field == 'status') {
					var state = 'disarmed';
					if (newVal.nr == 4) { // Armed Home
						state = 'partially_armed';
					} else if (newVal.armed) {
						state = 'armed';
					}
					var detail = newVal.nr.toString();
					var detailTxt = pm.sysStatus[locale][detail];
					panels[id].state = { arm: state, detail: detail };
					driver.realtime(device, 'homealarm_state', state, function(err, success) {
						debug('Real-time homealarm_state update:', id, (err ? err : 'OK'));
					});
					driver.realtime(device, 'arm_state', detailTxt, function(err, success) {
						debug('Real-time arm_state update:', id, (err ? err : 'OK'));
					});
					Homey.manager('flow').triggerDevice('status', { status: newVal.txt }, { panel: id, status: newVal.nr }, device);
				} else if (field == 'alarm') {
					// For all zones in alarm
					for (let i in panels[id].pm.zone) {
						if (i.slice(0, 5) === 'zone.' && panels[id].pm.zone[i].alarm) {
							let nr = i.slice(5);
							let name = self.getZoneName(id, nr);
							Homey.manager('flow').triggerDevice('zonealarm', { zone: nr, name: name }, { state: newVal }, device);
						}
					}
					driver.realtime(device, field, newVal); // 'alarm' is separate capability
				} else if (field == 'alarmType') { // e.g. Intruder, Tamper, Panic, Fire, Emergency, Gas, Flood
					var text = newVal.txt || '';
					Homey.manager('flow').triggerDevice('panelalarm', { type: newVal.nr, name: text }, { state: text != '' }, device);
				} else if (field == 'troubleType') { // e.g. Communication, General, Battery, Power, Jamming, Telephone
					var text = newVal.txt || '';
					debug('Triggering device trouble', text);
					Homey.manager('flow').triggerDevice('paneltrouble', { type: newVal.nr, name: text }, { state: text != '' }, device);
				} else if (field == 'event') {
					var text = newVal.userText + ': ' + newVal.type + ' (' + new Date().toLocaleString(locale) + ')';
					debug('Triggering device trouble', text);
					Homey.manager('flow').triggerDevice('event', { type: newVal.type, trigger: newVal.userText }, { state: text != '' }, device);
					driver.setSettings(device, { event: text });
				} else { // ready, memory, trouble are capabilities
					driver.realtime(device, field, newVal);
				}
			});
			// Catch battery events
			panels[id].pm.events.on('battery', function(newVal) {
				var name = self.getZoneName(device.id, newVal.zone);
				Homey.manager('flow').triggerDevice('battery', { zone: newVal.zone, name: name }, { state: newVal.low }, device);
			});
		}
		// Add devices in the queue (if any)
		if (deviceQueue[id] != null) {
			for (var i = 0; i < deviceQueue[id].length; i++) {
				var q = deviceQueue[id][i];
				if (q.type == 'sensor') {
					self.addSensorDevice(q.driver, q.device, q.name);
				} else {
					self.addX10Device(q.driver, q.device, q.name);
				}
				q.driver.setAvailable(q.device);
			}
		}
		// Search now done
		panelSearch = null;
	},
	
	// Cancel a panel search in progress
	cancelPanelSearch: function() {
		if (panelSearch != null) {
			panelSearch.found = 'no'; // make sure we don't re-open the connection
			panelSearch.closeConnection();
			if (panelSearch.settings != null) {
				// Panel already registered, remove it
				delete(panels[panelSearch.settings.config.panelSerial]);
			}
			panelSearch = null;
		}
	},
	
	// Remove a panel
	deletePanel: function(id) {
		if (panels[id] != null) {
			panels[id].pm.found = 'no'; // make sure we don't re-open the connection
			panels[id].pm.closeConnection();
			// mark all devices as unavailable
			if (panels[id].children != null) {
				for (var i = 0; i < panels[id].children.length; i++) {
					panels[id].children[i].driver.setUnavailable(panels[id].children[i].device, __('error.no_panel'));
				}
			}
			delete panels[id];
		} else {
			debug('Error: panel', id, 'not present.');
		}
	},
	
	// Get a list of all registered panels
	getPanels: function() {
		var list = [];
		for (var item in panels) {
			var elem = panels[item].pm.settings.config;
			list.push({ 
				id: item,
				type: elem.panelType,
				name: elem.panelModel,
				serial: elem.panelSerial,
				hname: panels[item].name
			});
		}
		return list;
	},
	
	// Update the end-user name of the panel
	updatePanelName: function(id, name) {
		if (panels[id] != null) {
			panels[id].name = name;
		}
	},
	
	// Get a list of panel status
	getPanelStatus: function(panel) {
		var result;
		if (panels[panel] != null) {
			result = panels[panel].pm.zone.system
		}
		return result;
	},
	
	// Get the state of the panel
	getPanelState: function(panel, field) {
		var result;
		if (panels[panel] && panels[panel].state[field]) {
			result = panels[panel].state[field];
		}
		return result;
	},

	getPanelArmState: function(panel) {
		var val = self.getPanelState(panel, 'detail');
		if (val != null) {
			val = pm.sysStatus[locale][val];
		}
		return val;
	},
	
	// Set the state of the panel
	setPanelState: function(panel, state, callback) {
		if (panels[panel] != null) {
			var newState = (state == 'partially_armed' ? 'Stay' : state[0].toUpperCase() + state.slice(1));
			var armCode = pm.armMode[newState];
			var allowed = true;
			var allowArming = panels[panel].settings.allowArm;

			debug('setPanelState', (state || 'N/A'));
			if (armCode != null) {
				if (allowArming == 'none') {
					allowed = false;
				} else if (allowArming == 'arm') {
					allowed = (armCode & 0x4) == 0x4; // allow 0x04/0x14 & 0x05/0x15
				} else if (allowArming == 'stay') {
					allowed = (armCode & 0x5) == 0x4; // allow 0x04 / 0x14
				}
				if (allowed && panels[panel].pm.readAllSettings) {
					var user = panels[panel].settings.armUser || 1;
					var pin = panels[panel].pm.settings.config.userCode[user - 1];
					panels[panel].pm.sendMessage("MSG_ARM", { arm: [ armCode ], pin: pin });
					callback(null, true);
				} else {
					callback('Not allowed');
				}
			} else {
				callback('Invalid state requested');
			}
		} else {
			callback('Panel does not exist');
		}
	},
	
	// Get the status of a panel variable
	getPanelValue: function(panel, name) {
		var result;
		if (panels[panel] != null && panels[panel].pm.zone.system != null) {
			result = panels[panel].pm.zone.system[name];
		}
		return result;
	},
	
	// Get a list of issues with the panel
	getPanelTrouble: function(panel) {
		var result = { panel: [], alarm: [], battery: [], tamper: [] };
		if (panels[panel] != null) {
			// Check panel trouble status
			var t = self.getPanelValue(panel, 'troubleType');
			if (t != null && t.txt != null) {
				result.panel.push([{ txt: t.txt }]);
			}
			// List alarms also as trouble
			t = self.getPanelValue(panel, 'alarmType');
			if (t != null && t.txt != null) {
				result.panel.push({ txt: t.txt });
			}
			// Check sensor issues
			// We only look at sensors that are visible in Homey
			for (var i = 0; i < panels[panel].children.length; i++) {
				if (panels[panel].children[i].type == 'sensor') {
					var zonenr = panels[panel].children[i].device.zone;
					var name = panels[panel].children[i].name;
					var zone = panels[panel].pm.zone['zone.' + zonenr];
					if (zone != null) {
						if (zone.battery) {
							result.battery.push({ nr: zonenr, txt: name });
						} else if (zone.alarm || zone.memory) {
							result.alarm.push({ nr: zonenr, txt: name });
						} else if (zone.tamper) {
							result.tamper.push({ nr: zonenr, txt: name });
						}
					}
				}
			}
		}
		return result;
	},
	
	// Set the time on the PowerMax panel
	setClock: function(panel) {
		if (panels[panel] != null) {
			panels[panel].pm.syncTime();
		}
	},
	
	// Add a sensor device
	addSensorDevice: function(driver, device, name) {
		var panel = device.panel;
		var data = { type: 'sensor', driver: driver, device: device, name: name };
		if (panels[panel] != null) {
			debug("Adding device " + device.id);
			panels[panel].children.push(data);
			var did = device.id.split(':');
			panels[panel].pm.events.on('zone.' + did[1], function(field, newVal) {
				var now = new Date().toLocaleString(locale);
				if (field == 'battery') {
					if (newVal) {
						driver.setSettings(device, { battery: now });
					}
					driver.realtime(device, 'alarm_battery', newVal, function(err, success) {
						debug('Real-time battery update zone', did[1] + ':', (err ? err : 'OK'));
					});
				} else if (field == 'tamper') {
					if (newVal) {
						driver.setSettings(device, { tamper: now });
					}
					driver.realtime(device, 'alarm_tamper', newVal, function(err, success) {
						debug('Real-time tamper update zone', did[1] + ':', (err ? err : 'OK'));
					});
				} else if (field == 'trip') {
					if (newVal) {
						driver.setSettings(device, { trip: now });
					}
					var event = (did[0] == 'magnet') ? 'alarm_contact' : (did[0] == 'motion' ? 'alarm_motion' : 'alarm_smoke');
					driver.realtime(device, event, newVal, function(err, success) {
						debug('Real-time tripped update zone', did[1] + ':', (err ? err : 'OK'));
					});
				}
			});
		} else {
			addToQueue(panel, data);
		}
	},
	
	// Delete a sensor/x10 device
	deleteDevice: function(device) {
		debug('Deleting device', device.id);
		var panel = device.panel;
		if (panels[panel] != null) {
			for (var i = 0; i < panels[panel].children.length; i++) {
				if (panels[panel].children[i].device.id == device.id) {
					var dev = panels[panel].children[i];
					panels[panel].children.splice(i, 1);
				}
			}
			// Remove events
			var did = device.id.split(':');
			panels[panel].pm.events.removeAllListeners('zone.' + did[1]);
			panels[panel].pm.events.removeAllListeners('x10.' + did[1]);
		}
	},
	
	// Update the end-user name of the device
	updateDeviceName: function(device_data, name) {
		var panel = device_data.panel;
		var device_id = device_data.id;
		if (panels[panel] != null) {
			for (var i = 0; i < panels[panel].children.length; i++) {
				if (panels[panel].children[i].device.id == device_id) {
					panels[panel].children[i].name = name;
				}
			}
		}
	},

	// Get all sensors the panel has registered
	getSensors: function(panel, type) {
		var items = [];
		if (panels[panel] != null) {
			var list = panels[panel].pm.settings.zones;
			if (panels[panel].pm.readAllSettings) {
				for (var idx in list) {
					var elem = list[idx];
					var setting = { 
						zone: idx,
						location: elem.zname,
						type: elem.ztypeName,
						chime: elem.zchime,
						partition: elem.partition.join(', ')
					};
					if ((type == 'magnet' || type == 'wired') && elem.stype == 'Magnet') {
						var capabilities = ['alarm_contact', 'alarm_tamper'];
						if (type == 'magnet') {
							capabilities.splice(1, 0, 'alarm_battery');
						}
						items.push({
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'magnet:' + idx, panel: panel, zone: idx },
							capabilities: capabilities,
							settings: setting
						});
					} else if (type == 'motion' && elem.stype == 'Motion') {
						items.push({ 
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'motion:' + idx, panel: panel, zone: idx },
							capabilities: ['alarm_motion', 'alarm_battery', 'alarm_tamper'],
							settings: setting
						});
					} else if (type == 'smoke' && elem.stype == 'Smoke') {
						items.push({ 
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'smoke:' + idx, panel: panel, zone: idx },
							capabilities: ['alarm_smoke', 'alarm_battery', 'alarm_tamper'],
							settings: setting
						});
					}
				}
			}
		}
		return items;
	},
	
	// Get a sensor value
	getZoneValue: function(trigger, panel, zone, callback) {
		if (panels[panel] != null) {
			var zone = 'zone.' + zone;
			var val;
			if (panels[panel].pm.zone[zone] != null) { // fix #3
				if (trigger == 'alarm_contact' || trigger == 'alarm_motion' || trigger == 'alarm_smoke') {
					val = panels[panel].pm.zone[zone].trip;
					debug('Tripped:', val);
				} else if (trigger == 'alarm_battery') {
					val = panels[panel].pm.zone[zone].battery;
					debug('Battery:', val);
				} else if (trigger == 'alarm_tamper') {
					val = panels[panel].pm.zone[zone].tamper;
					debug('Tamper:', val);
				}
			}
			callback(null, val);
		} else {
			// Panel has been removed
			callback('Panel does not exist');
		}
	},
	
	// Get the name of the zone
	getZoneName: function(panel, zone) {
		var name = locale == 'en' ? 'Unknown' : 'Onbekend';
		if (panels[panel] != null) {
			var zones = panels[panel].pm.settings.zones;
			if (zones != null && zones[zone] != null) {
				name = zones[zone].zname;
			}
		}
		return name;
	},
	
	// Get the list of open zones
	getOpenZones: function(panel) {
		var zones = [];
		if (panels[panel] != null) {
			// We only list sensors that are visible in Homey
			for (var i = 0; i < panels[panel].children.length; i++) {
				if (panels[panel].children[i].type == 'sensor') {
					var zonenr = panels[panel].children[i].device.zone;
					var zone = panels[panel].pm.zone['zone.' + zonenr];
					if (zone != null && zone.trip) {
						var sensordriver = panels[panel].children[i].driver;
						zones.push({ nr: zonenr, name: panels[panel].children[i].name });
					}
				}
			}
		}
		return zones;
	},
	
	// Add a X10 device
	addX10Device: function(driver, device, name) {
		var panel = device.panel;
		var data = { type: 'x10', driver: driver, device: device, name: name };
		if (panels[panel] != null) {
			debug('Adding device', device.id);
			panels[panel].children.push(data);
			var did = device.id.split(':');
			panels[panel].pm.events.on('x10.' + did[1], function(field, newVal) {
				if (field == 'on') {
					driver.realtime(device, 'onoff', newVal, function(err, success) {
						debug('Real-time on/off update x10', did[1] + ':', (err ? err : 'OK'));
					});
				}
			});
		} else {
			addToQueue(panel, data);
		}
	},
	

	// Get all X10 devices the panel has registered
	getX10Devices: function(panel, pgm) {
		var items = [];
		if (panels[panel] != null) {
			if (panels[panel].pm.readAllSettings) {
				var list = panels[panel].pm.settings.x10;
				for (var idx in list) {
					var elem = list[idx];
					var capabilities = [ 'onoff' ];
					if ((elem.nr == 0 && pgm) || elem.nr > 0 && !pgm) {
						var id = 'x10:' + idx;
						if (elem.nr != 0) {
							capabilities.push('dim_oneway'); // TODO: choice for dim
						} else {
							id = 'x10:PGM';
						}
						var loc = elem.loc == null ? '' : ' (' + elem.loc + ')';
						items.push({
							name: elem.name + loc,
							data: {	id: id, panel: panel, nr: elem.nr },
							capabilities: capabilities
						});
					}
				}
			}
		}
		return items;
	},
	
	// Get the on/off state of the X10 device
	getX10State: function(panel, nr, callback) {
		var result;
		if (panels[panel] != null) {
			var id = 'x10.' + (nr == 0 ? 'PGM' : nr);
			if (panels[panel].pm.zone[id] != null) {
				result = panels[panel].pm.zone[id].on;
			}
		}
		callback(null, result)
	},
	
	// Send a X10 command to the panel
	sendX10Command: function(panel, nr, state) {
		if (panels[panel] != null) {
			if (state == 'toggle') {
				state = (panels[panel].pm.zone['x10.' + nr].on ? 'off' : 'on');
			}
			panels[panel].pm.sendX10Command([ nr ], state);
		}
	},
	
	// Update panel configuration settings
	updatePanelSettings: function(panel, changedItems, newSettings) {
		var result = { msg: __('settings.saved'), updates: {} };
		if (panels[panel] != null) { // Fix #5
			// First check the pin-code before making any changes
			var p = panels[panel].pm;
			var idx = changedItems.indexOf('pin')
			if (idx >= 0) {
				if (panels[panel].pm.readAllSettings && newSettings.pin == p.settings.config.masterCode.val) {
					var restart = false;
					// Remove the pin code
					changedItems.splice(idx, 1);
					for (var i in changedItems) {
						var item = changedItems[i];
						var newVal = newSettings[item];
						// Check if special action needed
						if (item == 'ip' || item == 'port') {
							// We will need to close connection & restart
							restart = true;
						} else if (item == 'syncTime' && newVal) {
							p.syncTime();
						} else if (item == 'armUser') {
							// Check that there is a pin code for this user
							var pin = panels[panel].pm.settings.config.userCode[newVal - 1];
							debug(pin);
							if (pin == null) {
								result.msg = __('settings.invalid_user', { user: newVal });
								result.updates = {};
								return result;
							}
						}
						// Update setting
						p.devSettings[item] = newVal; // TODO: store only in one place
						panels[panel].settings[item] = newVal;
						// Add to results to be updated
						result.updates[item] = newVal;
					}
					if (restart) {
						p.found = 'inactive';
						p.handleCommException('IP address changed');
					}
				} else {
					result.msg = __('settings.invalid_pin');
				}
			} else {
				result.msg = __('settings.no_pin');
			}
		} else {
			result.msg = __('error.invalid_panel', { panel: panel });
		}
		return result;
	}
}
