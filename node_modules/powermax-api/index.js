"use strict";

var PowerMax = require('./lib/core.js'),
	pm = require('./lib/tables.js');

var debugOn = true;
var panels = [];
var panelState = [];
var locale = Homey.manager('i18n').getLanguage();

var allowArming = 'all';
	
// Debug logging
function debug(text) {
	if (debugOn) {
		var now = new Date();
		if (typeof text == 'object') {
			var output = '';
			for (var property in text) {
			  output += property + ': ' + text[property]+'; ';
			};
			text = output;
		}
		var time = now.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1");
		var ms = ('00' + now.getMilliseconds()).slice(-3);
		Homey.log(time + '.' + ms + ' ' + text);
	}
}

var self = module.exports = {
	// debug function
	debug: debug,
	
	// Add a new panel
	addPanel: function(ip, port) {
		var id = ip + ':' + port;
		if (panels[id] == null) {
			var powermax = new PowerMax(ip, port, debug);
			panels[id] = powermax;
			// Add event handlers
			powermax.events.on('found', function(data) {
				if (!data.found) {
					delete panels[id];
				}
				Homey.emit('found', data);
			});
			powermax.events.on('download', function(state) {
				var data = { state: state };
				if (state == 'done') {
					data.config = panels[id].settings.config;
					data.device = { 
						name: data.config.panelType,
						data: {	id: id },
						settings: { 
							ip: ip, port: Number(port) ,
							allowArm: 'all', syncTime: true
						}
					}
				}
				Homey.emit('download', data);
			});
		} else {
			debug('Error: panel ' + id + ' already present.');
			Homey.emit('found', { found: false });
		}
	},
	
	addPanelActions: function(driver, device) {
		var id = device.id;
		panels[id].events.on('system', function(id, field, newVal) {
			if (field == 'status') {
				var state = 'disarmed';
				if (newVal.nr == 4) { // Armed Home
					state = 'partially_armed';
				} else if (newVal.armed) {
					state = 'armed';
				}
				panelState[device.id] = state;
				driver.realtime(device, 'homealarm_state', state, function(err, success) {
					debug('Real-time panel update: ' + (err ? err : 'OK'));
				});
			}
		});
	},
	
	// Remove a panel
	deletePanel: function(id) {
		if (panels[id] != null) {
			panels[id].closeConnection();
			delete panels[id];
		} else {
			debug('Error: panel ' + id + ' not present.');
		}
	},
	
	// Get a list of all registered panels
	getPanels: function() {
		var list = [];
		for (var item in panels) {
			var elem = panels[item].settings.config;
			list.push({ 
				id: item,
				type: elem.panelType,
				name: elem.panelName,
				serial: elem.panelSerial
			});
		}
		return list;
	},
	
	// Get the configuration of a panel
	getPanelDetails: function(id) {
		var details = {};
		var powermax = panels[id];
		if (powermax != null) {
			var config = powermax.settings.config;
			for (var i in pm.info) {
				var item = pm.info[i];
				var val = config[item.val];
				if (val != null) {
					details[i] = { name: item[locale], val: val };
				}
			}
		}
		return details;
	},
	
	// Add a sensor device
	addDevice: function(driver, device) {
		debug("Adding device " + device.id);
		var panel = device.panel;
		if (panels[panel] != null) {
			panels[panel].events.on('zone', function(id, field, newVal) {
				var did = device.id.split(':');
				if (id == did[1]) {
					if (field == 'battery') {
						driver.realtime(device, 'alarm_battery', newVal, function(err, success) {
							debug('Real-time battery update: ' + (err ? err : 'OK'));
						});
					} else if (field == 'tamper') {
						driver.realtime(device, 'alarm_tamper', newVal, function(err, success) {
							debug('Real-time tamper update: ' + (err ? err : 'OK'));
						});
					} else if (field == 'trip') {
						var event = (did[0] == 'magnet') ? 'alarm_contact' : (did[0] == 'motion' ? 'alarm_motion' : 'alarm_smoke');
						driver.realtime(device, event, newVal, function(err, success) {
							debug('Real-time tripped update: ' + (err ? err : 'OK'));
						});
					}
				}
			});
		}
	},
	
	// Delete a (sensor) device
	deleteDevice: function(device) {
		debug("Deleting device " + device.id);
		// TODO: remove events
	},
	
	// Get sensors
	getSensors: function(panel, type) {
		var items = [];
		if (panels[panel] != null) {
			var list = panels[panel].settings.zones;
			if (panels[panel].readAllSettings) {
				for (var idx in list) {
					var elem = list[idx];
					if ((type == 'magnet' || type == 'wired') && elem.stype == 'Magnet') {
						var capabilities = ['alarm_contact', 'alarm_tamper'];
						if (type == 'magnet') {
							capabilities.splice(1, 0, 'alarm_battery');
						}
						items.push({
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'magnet:' + idx, panel: panel, zone: idx },
							capabilities: capabilities
						});
					} else if (type == 'motion' && elem.stype == 'Motion') {
						items.push({ 
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'motion:' + idx, panel: panel, zone: idx },
							capabilities: ['alarm_motion', 'alarm_battery', 'alarm_tamper']
						});
					} else if (type == 'smoke' && elem.stype == 'Smoke') {
						items.push({ 
							name: elem.zname + ' (zone ' + idx + ')',
							data: {	id: 'smoke:' + idx, panel: panel, zone: idx },
							capabilities: ['alarm_smoke', 'alarm_battery', 'alarm_tamper']
						});
					}
				}
			}
		}
		return items;
	},
	
	// Get a sensor value
	getValue: function(trigger, panel, zone, callback) {
		if (panels[panel] != null) {
			if (trigger == 'alarm_contact' || trigger == 'alarm_motion' || trigger == 'alarm_smoke') {
				var val = panels[panel].panel.zone[zone].trip;
				debug('Tripped: ' + val);
			} else if (trigger == 'alarm_battery') {
				var val = panels[panel].panel.zone[zone].battery;
				debug('Battery: ' + val);
			} else if (trigger == 'alarm_tamper') {
				var val = panels[panel].panel.zone[zone].tamper;
				debug('Tamper: ' + val);
			}
			callback(null, val);
		} else {
			// Panel has been removed
			callback('Panel does not exist');
		}
	},
	
	// Get the state of the panel
	getPanelState: function(panel) {
		return panelState[panel];
	},

	// Set the state of the panel
	setPanelState: function(panel, state, callback) {
		var newState = (state == 'partially_armed' ? 'Stay' : state[0].toUpperCase() + state.slice(1));
		var armCode = pm.armMode[newState];
		var allowed = true;

		debug('setPanelState ' + (state || 'N/A'));
		if (armCode != null) {
			if (allowArming == 'none') {
				allowed = false;
			} else if (allowArming == 'arm') {
				allowed = (armCode & 0x5) == 0x5;
			} else if (allowArming == 'stay') {
				allowed = (armCode & 0x5) != 0;
			} else {
				allowed = true;
			}
			if (allowed) {
				var pin = panels[panel].settings.config.userCode[0];
				panels[panel].sendMessage("MSG_ARM", { arm: [ armCode ], pin: pin });
				callback(null, true);
			} else {
				callback('Not allowed', false);
			}
		} else {
			callback('Invalid state requested', false);
		}
	}
}
