"use strict";

var pm  = require('./tables.js'),
	net = require('net'),
	event = require('events'),
	handler = require('./handlers.js'),
	Settings = require('./settings.js');

var locale = Homey.manager('i18n').getLanguage();

var	MSG_RETRIES = 3;
var MAX_CRC_ERROR = 3;
var TIMEOUT = 3600;
	
function pduToString(pdu) {
    var PDUstr = '';
	for (var i = 0; i < pdu.length; i++) {
		PDUstr += ('0' + pdu[i].toString(16)).slice(-2) + ' ';
	}
    return PDUstr;
}

/*
   Events:
   - found: a PowerMax device has been found; param: found (true/false)
   - zone: a zone sensor has changed state; param: id, field, newVal (id = zone nr, 
		field = ['trip', 'tamper', 'battery', 'bypass'])
   - x10: an x10 device has changed state; param: id, field, newVal (id = x10 nr, field = ['on'])
   - system: the panel system state has changed; param: id, field, newVal (id = 0, 
		field = ['status', 'ready', 'memory', 'trouble', 'alarm'])
			status: { armed (boolean), nr (int), txt (string) }, others return boolean
   - alarm: the alarm state has changed; param: id, field, newVal ??
*/

// Main constructor
function PowerMax(settings, debug) {

	var self = this;
	this.id = settings.ip + ':' + settings.port;
	this.devSettings = settings;
	this.debug = function(text) { debug('[' + self.id + '] ' + text); };
	this.client;
	this.found = false;
	// Event handling
	this.events = new event.EventEmitter();
	// Incoming message handling
	this.incomingPdu =[];
	this.incomingPduLen = 0; // expected length
	this.varLenMsg = false;
	this.lastPdu = [];
	this.expectedResponse = [];
	this.waitingForResponse = false;
	this.crcErrorCount = 0;
	// Outgoing message handling
	this.outgoingQueue = [];
	this.msgDelayed = null;
	this.sendMsgRetries = 0;
	// Panel configuration
	this.panelTypeNr = 0;
	this.powerMaster = false;
	this.starting = false;
	this.powerlinkMode = false;
	// Panel settings
	this.settings = new Settings(this);
	this.readAllSettings = false;
	this.downloadState;
	// State of each zone
	this.panel = {};
	this.motionTimeout = [];
	
	this.events.setMaxListeners(0); // infinity
	/*
	this.events.on('zone', function(id, field, value) {
		Homey.log('Zone status changed for zone ' + id + '; ' + field + ' = ' + value);
	});
	this.events.on('system', function(id, field, value) {
		Homey.log('System status changed for ' + field + ' = ' + value);
	});
	*/
	this.events.on('download', function(state) {
		this.downloadState = state; // can be 'start', 'failed' or 'done'
	});

	this.openConnection(settings.ip, settings.port);
}

// Open the connection to this PowerMax panel
PowerMax.prototype.openConnection = function(ip, port) {
	var self = this;
	
	// Set up network communication
	this.client = new net.Socket();
	this.client.setTimeout(60000); // expect traffic once a minute
	// Register main response handler
	this.client.on('data', function(data) {
		//clearTimeout(waitTimer);
		self.processData(data);
	});
	// Error handler
	this.client.on('error', function(err) {
		self.debug(err);
		if (!self.found) {
			//clearTimeout(waitTimer);
			self.closeConnection();
		}
	});
	// Timeout handler
	this.client.on('timeout', function() {
		self.debug('Connecion timed out.');
		self.closeConnection();
	});
	// Handle closed connections, try to re-open it
	this.client.on('close', function() {
		self.debug('Connecion closed (found = ' + self.found + ')');
		if (self.found) {
			// Connection dropped, try to re-connect
			
		}
	});
	this.client.connect(port, ip, function() {
		self.debug('Connected to ' + self.id);
		// Kill the re-try timer
		//clearTimeout(reconnectTimer);
		// Search for the PowerMax
		//clearTimeout(waitTimer);
		// Start communication
		self.startDownload();
	});
}

// Close the connection to this PowerMax panel
PowerMax.prototype.closeConnection = function() {
	this.client.destroy();
	this.events.emit('found', { found: false });
}

// Determine whether we are in normal operating mode or not
PowerMax.prototype.isNormalMode = function() {
	var lastType = this.lastPdu[1];
	var normalMode = (lastType >= 0x80 || ((lastType < 0x10) && this.lastPdu[this.lastPdu.length - 2]) == 0x43);
	return normalMode;
}

// sendPdu: Send the pdu to the PowerMax via serial
PowerMax.prototype.sendPdu = function(pdu) {
	var sendPdu = pm.calcCRC(pdu);
	var PDUstr = pduToString(sendPdu);
	this.debug("PDU sent to panel: " + PDUstr);
	this.client.write(new Buffer(sendPdu));
	return sendPdu;
}

// sendAck: Send full or partial acknowledge to Powermax (depending on operating mode)
PowerMax.prototype.sendAck = function(ackType) {
	if (this.isNormalMode() == true) {
		this.sendPdu([0x0D, ackType, 0x43, 0x00, 0x0A]);
	} else {
		this.sendPdu([0x0D, ackType, 0x00, 0x0A]);
	}
}

// startDownload
PowerMax.prototype.startDownload = function() {
	if (this.starting == false) {
		this.events.emit('download', 'enroll');
		this.starting = true;
		this.sendMessage("MSG_DOWNLOAD", { code: pm.secret }); // If we get a NACK, then the download code is not valid (not enrolled)
		this.lastKeepAlive = new Date();
	} else {
		this.debug("Download not started as one is in progress.")
	}
}


// writeMessage
// item: address
//   or: DL_xxx
PowerMax.prototype.writeMessage = function(item, val) {
	var len = val.length;
	var addr;
	if (typeof item == 'string') {
		addr = pm.download[item].slice(0, 1);
	} else {
		addr = [item % 0x100, math.floor(item / 0x100)];
	}
	while (len > 0) {
		var s = val.slice(0, 0xAF);
		var l = (len > 0xB0) ? 0xB0 : len;
		this.debug('addr = ' + addr + ', len = ' + l);
		this.sendMessage("MSG_WRITE", { addr: addr, len: l, val: s });
		var page = string.byte(addr, 2)
		var index = string.byte(addr)
		//pmWriteSettings(page, index, s) // also update internal table
		len -= 0xB0;
		val = val.slice(0xB0);
		var a = 0x100 * page + index + 0xB0;
		addr = [a % 0x100, math.floor(a / 0x100)];
    }
}

// sendDelayed
PowerMax.prototype.sendDelayed = function() {
   this.debug("*** Trigger: delayed sending ***");
   // Check if we have received another message in the meantime
   var interval = new Date() - this.waitingForResponse;
   var wait = (interval <= 500);
   if (wait == true) {
		// not yet 500 ms since last receive; we cannot send yet
		var self = this;
		setTimeout(function() { self.sendDelayed() }, 500 - interval);
	} else {
		this.sendMessage(-2);
	}
}

// sendMessage: Send (known) messages to the PowerMax
// Returns success: true: sent or queued; false: nothing sent 
PowerMax.prototype.sendMessage = function(msg, modifiers, immediate) {
	var outPdu = [];
	var response;
	var interval = new Date() - this.waitingForResponse;
	var timeout = (interval > TIMEOUT);
	
	if (msg == -1) { // re-send last message
		outPdu = this.lastSentPdu;
		response = this.expectedResponse;
		timeout = true;
	} else if (msg == -2) { // send message delayed
		outPdu = this.msgDelayed.pdu;
		response = this.msgDelayed.resp;
		this.msgDelayed = null;
		timeout = true;
	} else if (msg != null) {
		msg = pm.send[msg];
		outPdu = [0x0D];
		
		for (var i = 0; i < msg.msg.length; i++) {
			if (typeof msg.msg[i] != 'string') {
				outPdu.push(msg.msg[i]);
			} else {
				// handle modifier
				outPdu = outPdu.concat(modifiers[msg.msg[i]]);
			}
		}
		outPdu.push(0x00, 0x0A);
		response = msg.resp != null ? [ msg.resp ] : null;

		if (outPdu[1] == 0x3E) {
			var cnt = outPdu[4] + 0x100 * outPdu[5];
			//TODO: optimize
			for (var i = 0; i < Math.floor(cnt / 0xB0); i++) {
				response.push(msg.resp);
			}
		}
	}
   
	if (immediate == true || (this.msgDelayed == null) && (timeout == true || this.expectedResponse.length == 0)) { // we are ready to send
		if (msg == null) { // get message from queue
			var tab = this.outgoingQueue.shift();
			if (tab == null) {
				// nothing to send
				return false
			}
			outPdu = tab.pdu;
			response = tab.resp;
		}
		// always expect an ACK (ACK send messages don't pass through here)
		// check if the last read is at least 500 ms ago
		var wait = (interval <= 500);
		if (wait == true && immediate != true) {
			// there should be at least 500 ms between last receive and a new send
			this.debug("*** Send message delayed ***")
			this.msgDelayed = { pdu: outPdu, resp: response };
			var self = this;
			setTimeout(function() { self.sendDelayed(); }, 500 - interval);
			return true;
		}
		this.expectedResponse = response != null ? [0x02].concat(response) : [0x02];
		this.lastPdu = this.sendPdu(outPdu);
		this.lastSentPdu = this.lastPdu;
		// TODO: check how to return false if sending failed
		this.waitingForResponse = new Date();
	} else if (msg != null) { // queue message
		this.outgoingQueue.push({ pdu: outPdu, resp: response });
	}
	return true;
}

// Process incoming PDUs
PowerMax.prototype.processData = function(data) {
	// Don't assume we get a full PDU right away
	for (var p = 0; p < data.length; p++) {
		var pdu = data[p];
		var pduLen = this.incomingPdu.length;
		var success, ignore;

		if (pduLen == 4 && this.varLenMsg == true) {
			// Determine length of variable size message
			var msgType = '0x' + ('0'+ this.incomingPdu[1].toString(16).toUpperCase()).slice(-2);
			this.incomingPduLen += pdu + 7
			this.debug('Message ' + msgType + '; incomingPduLen = ' + this.incomingPduLen);
		}
	   
	   if (pduLen == 0) {
			if (pdu == 0x0D) { // preamble
				var response = '';
				if (this.expectedResponse.length != 0) {
					response = pduToString(this.expectedResponse);
					if (response != '') {
						response = "; Expecting " + response;
					}
				}
				this.debug("Start of new PDU detected " + response);
				this.incomingPdu[0] = pdu;
			}
		} else if (pduLen == 1) {
			var msgType = '0x' + ('0'+ pdu.toString(16).toUpperCase()).slice(-2);
			var msgType_t = pm.receive[msgType];
			this.incomingPduLen = msgType_t.len || 0;
			this.varLenMsg = (msgType > 0x10) && (msgType_t != null) && (msgType_t.len == null);
			this.debug('Message ' + msgType + '; incomingPduLen = ' + this.incomingPduLen);
			this.incomingPdu.push(pdu);
		} else if ((this.incomingPduLen == 0 && pdu == 0x0A) || (pduLen + 1 == this.incomingPduLen)) { // postamble
			this.incomingPdu.push(pdu);
			if (!this.found) {
				this.found = true;
				this.events.emit('found', { found: true });
			}
			var crc;
			var msgType = '0x' + ('0'+ this.incomingPdu[1].toString(16).toUpperCase()).slice(-2);
			if (pdu != 0x0A && this.incomingPdu[pduLen - 1] == 0x43) {
				this.incomingPduLen++; // for 0x43
			} else if (crc = pm.checkCRC(this.incomingPdu) == true) {
				this.lastPdu = this.incomingPdu;
				var PDUstr = pduToString(this.incomingPdu);
				var msgType_t = pm.receive[msgType];
				this.debug("PDU received " + PDUstr);
				this.waitingForResponse = new Date();
		 
				if (msgType_t == null) {
					this.debug('Unhandled message ' + msgType);
					this.sendAck(0x02);
				} else {
					// Send an ACK if needed
					if (msgType_t.ack) {
					   this.sendAck(0x02);
					}
					// Handle the message
					var success, ignore;
					var call = handler[msgType_t.handler];
					if (call == null) {
						this.debug('Unhandled message ' + msgType + '; handler: ' + msgType_t.handler);
					} else {
						success, ignore = call(this);
					}
					// Check response
					if (this.expectedResponse.length != 0) {
						// We've sent something and are waiting for a response - this is it
						var firstExpectedResponse = this.expectedResponse[0];
						this.expectedResponse = this.expectedResponse.slice(1);
						if (firstExpectedResponse != msgType) {
							if (ignore == true) { // ignore unexpected messages
								this.debug('Ignoring response...');
								this.expectedResponse.unshift(firstExpectedResponse);
							} else if (this.sendMsgRetries == 0) {
								this.debug("*** Waiting for next PDU (expected " + firstExpectedResponse.toString(16) + " got " + msgType + ") ***");
								this.sendMsgRetries = 1; // don't respond immediately - first wait for the next response
								this.expectedResponse.unshift(firstExpectedResponse);
							} else {
								this.debug("*** Re-sending PDU (expected " + firstExpectedResponse.toString(16) + " got " + msgType + ") ***");
								if (this.sendMsgRetries == MSG_RETRIES) {
									//pmHandleCommException("wrong response");
								} else {
									this.sendMsgRetries++;
									this.sendMessage(-1);
								}
							}
						} else {
							this.sendMsgRetries = 0;
						}
					}
				}
				this.incomingPdu = [];
				if (this.expectedResponse.length == 0) {
					this.sendMessage(null);
				}
			} else { // CRC check failed
				this.debug(crc);
				if (this.incomingPduLen > 0) {
					var PDUstr = pduToString(this.incomingPdu);
					this.debug("PDU with CRC error " + PDUstr);
					this.waitingForResponse = new Date();
					this.incomingPdu = [];
					if (msgType != 0xF1) { // ignore CRC errors on F1 message
						this.crcErrorCount++;
					}
					if (this.crcErrorCount > MAX_CRC_ERROR) {
						//pmHandleCommException("CRC errors")
					}
				} else {
					this.debug("Length is now " + pduLen + "(apparently PDU not complete)");
					var PDUstr = pduToString(this.incomingPdu);
					this.debug("Partial PDU " + PDUstr);
				}
			}
		} else if (pduLen <= 0xC0) {
			this.incomingPdu.push(pdu);
		} else {
			var PDUstr = pduToString(this.incomingPdu);
			this.debug("Truncating PDU " + PDUstr);
			this.incomingPdu = []; // messages should never be longer than 0xC0
		}
	} // end for
};

// Synchronize time from Homey to the PowerMax
PowerMax.prototype.syncTime = function() {
	this.sendMessage("MSG_DOWNLOAD", { code: pm.secret }); // Open download mode
	if (this.devSettings.syncTime) {
		var t = new Date();
		var year = t.getFullYear() - 2000;
		var timePdu = [t.getSeconds(), t.getMinutes(), t.getHours(), t.getDate(), t.getMonth() + 1, year];
		t.setMilliseconds(0);
		this.syncTimeCheck = t;
		this.sendMessage("MSG_SETTIME", { time: timePdu });
	}
	this.sendMessage("MSG_EXIT");  // Exit download mode
}

// powerlinkEnrolled
PowerMax.prototype.powerlinkEnrolled = function() {
	this.sendMessage("MSG_DL", { item: pm.download.MSG_DL_PANELFW }); // Request the panel FW
	this.sendMessage("MSG_DL", { item: pm.download.MSG_DL_SERIAL }); // Request serial & type (not always sent by default)
	this.sendMessage("MSG_DL", { item: pm.download.MSG_DL_ZONESTR }); // Read the names of the zones
	if (this.powerMaster) {
		this.sendMessage("MSG_DL", { item: pm.download.MSG_DL_MR_SIRKEYZON });
	}
	if (this.devSettings.syncTime) {
		var t = new Date();
		var year = t.getFullYear() - 2000;
		var timePdu = [t.getSeconds(), t.getMinutes(), t.getHours(), t.getDate(), t.getMonth() + 1, year];
		t.setMilliseconds(0);
		this.syncTimeCheck = t;
		this.sendMessage("MSG_SETTIME", { time: timePdu });
	}
	this.sendMessage("MSG_START"); // Start sending all relevant settings please
	this.sendMessage("MSG_EXIT");  // Exit download mode
}

module.exports = PowerMax;